<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Binary Search | Interview Bits]]></title>
  <link href="http://interviewbits.herokuapp.com/blog/categories/binary-search/atom.xml" rel="self"/>
  <link href="http://interviewbits.herokuapp.com/"/>
  <updated>2014-12-18T12:07:32+02:00</updated>
  <id>http://interviewbits.herokuapp.com/</id>
  <author>
    <name><![CDATA[Asaf David]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Plus Minus Array]]></title>
    <link href="http://interviewbits.herokuapp.com/blog/2014/12/01/plus-minus-array/"/>
    <updated>2014-12-01T23:17:39+02:00</updated>
    <id>http://interviewbits.herokuapp.com/blog/2014/12/01/plus-minus-array</id>
    <content type="html"><![CDATA[<p><strong>Question</strong>: We are givan an array <script type="math/tex">A</script> (with size <script type="math/tex">n</script>) where every cell holds either ‘+’ or ‘-‘.
We’re told that <script type="math/tex">A[0]</script> = ‘+’ and that <script type="math/tex">A[n-1]</script> = ‘-‘. Describe an algorithm to find index <script type="math/tex">j</script> such that <script type="math/tex">A[j]</script> = ‘+’
and <script type="math/tex">A[j+1]</script> = ‘-‘.</p>

<p><strong>Example</strong>: </p>

<table>
  <tbody>
    <tr>
      <td>A</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
      <td>-</td>
      <td>+</td>
      <td>-</td>
    </tr>
    <tr>
      <td>id</td>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
      <td>8</td>
      <td>9</td>
    </tr>
  </tbody>
</table>

<p>Correct answers in this example are <script type="math/tex">j=1</script>, <script type="math/tex">j=5</script>, <script type="math/tex">j=8</script> (each one is acceptable, no need to return them all).</p>

<hr />

<p><strong>Solution</strong>: We can use logic similar to binary search to solve this in <script type="math/tex">O(\log{} n)</script> time complexity. We’ll use two 
variables, <script type="math/tex">l</script> and <script type="math/tex">h</script>, and maintain the following invariant: <script type="math/tex">A[l]</script> = ‘+’ and <script type="math/tex">A[r]</script> = ‘-‘. In each step
we’ll check if <script type="math/tex">r=l+1</script>. If so, we’re done. else, we find the center point <script type="math/tex">c=\frac{l+r}{2}</script>. If <script type="math/tex">A[c</script>] = ‘+’ we’ll
update <script type="math/tex">l=c</script>, else <script type="math/tex">r=c</script>. Since in each step the distance between <script type="math/tex">l</script> and <script type="math/tex">r</script> diminishes, we know the process
will eventually terminate.</p>

<p>&#8220;` Scala
    class PlusMinusArray {
    def search(array: Array[Char]): Int = {
      def searchInner(l: Int, h: Int): Int = {
        if (h == l + 1) l else {
          val mid: Int = l + (h - l) / 2
          array(mid) match {
            case ‘+’ =&gt; searchInner(mid, h) 
            case ‘-‘ =&gt; searchInner(l, mid)
            case _   =&gt; throw new IllegalArgumentException(“invalid character “ + array(mid)) 
          }
        }
      }</p>

<pre><code>  searchInner(0, array.size - 1)
}
} ``` Have any questions / remarks? leave them at the commonts below!
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Square Root]]></title>
    <link href="http://interviewbits.herokuapp.com/blog/2014/11/29/square-root/"/>
    <updated>2014-11-29T18:20:21+02:00</updated>
    <id>http://interviewbits.herokuapp.com/blog/2014/11/29/square-root</id>
    <content type="html"><![CDATA[<p><strong>Question</strong>: Givan two real numbers <script type="math/tex">x</script> and <script type="math/tex">\epsilon</script>, find the square root of <script type="math/tex">x</script> within error margin of <script type="math/tex">\epsilon</script> (that is, find <script type="math/tex">y</script> such that <script type="math/tex">% &lt;![CDATA[
 \lvert \sqrt{x} - y \rvert < \epsilon %]]&gt;</script>). Obviously, you’re not allowed to use the startand <code>sqrt</code> function. </p>

<hr />

<p><strong>Solution</strong>: The general idea is to guess a solution <script type="math/tex">y</script> and then iteratively improve it. If <script type="math/tex">y^2 > x</script>, we should aim lower, so in the next step we’ll try <script type="math/tex">y - stepSize</script>. 
else, we should aim higher, so we’ll try <script type="math/tex">y + stepSize</script>. In each step we’ll halve the <script type="math/tex">stepSize</script>.</p>

<p>The following is a Scala implementation:</p>

<p>&#8220;` Scala
    class Sqrt {
      def sqrt(x : Double, err: Double): Double = sqrtHelper(x, err, 0.5 * x, 0.25 * x)</p>

<pre><code>  def sqrtHelper(x: Double, allowedError: Double, curr: Double, stepSize: Double): Double = {
    val err = x - (curr * curr)
    if (Math.abs(err) &lt;= allowedError)
      curr
    else
      sqrtHelper(x, allowedError, if (err &gt; 0) curr + stepSize else curr - stepSize, 0.5 * stepSize)
  }
} ```
</code></pre>

<p>Have any questions / remarks? leave them at the commonts below!</p>
]]></content>
  </entry>
  
</feed>
