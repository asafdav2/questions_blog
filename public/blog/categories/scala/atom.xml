<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Scala | My Octopress Blog]]></title>
  <link href="http://yoursite.com/blog/categories/scala/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2014-12-07T07:37:11+02:00</updated>
  <id>http://yoursite.com/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Sort by Length Then Frequency]]></title>
    <link href="http://yoursite.com/blog/2014/12/03/sort-by-length-then-frequency/"/>
    <updated>2014-12-03T19:32:20+02:00</updated>
    <id>http://yoursite.com/blog/2014/12/03/sort-by-length-then-frequency</id>
    <content type="html"><![CDATA[<p><strong>Question</strong>: Implement a function that takes a file name of text file that contains words (each in a different line, 
words may apper more than once), and returns the list of words (without duplications), sorted first by word 
length (descending) and then by number of occurrences (descending).</p>

<p>In other words, the longest word will appear first in the list. In case there are several words with the same
length, their inner order will be according to their appearences frequency.</p>

<p><strong>Example</strong>: assume the file <code>words.txt</code> contain the following content:</p>

<pre><code>ABC
ABC
ABB
ABCDE
A
B
B
B
</code></pre>

<p>Then running <code>sort("words.txt")</code> should return the following result:</p>

<pre><code>ABCDE ABC ABB B A
</code></pre>

<hr />

<p><strong>Solution</strong>:</p>

<p>The following is a Scala implementation:</p>

<p>&#8220;` Scala
    class Sorter {</p>

<pre><code>  def sort(filename: String): List[String] = sort(scala.io.Source.fromFile(filename).getLines().toList)

  def sort(words: List[String]): List[String] = 
    occurrences(words).toList
      .sortBy(r =&gt; (-r._1.length, -r._2))
      .map(r =&gt; r._1)
  

  def occurrences(words: List[String]) = 
    words.groupBy(l =&gt; l)
      .map(t =&gt; (t._1, t._2.length))

} ```
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Power Set]]></title>
    <link href="http://yoursite.com/blog/2014/12/03/power-set/"/>
    <updated>2014-12-03T19:32:20+02:00</updated>
    <id>http://yoursite.com/blog/2014/12/03/power-set</id>
    <content type="html"><![CDATA[<p><strong>Question</strong>: Given an integer <script type="math/tex">n</script>, implement a function to compute <script type="math/tex"> \mathcal P \left({n}\right)</script>, the <a href="http://en.wikipedia.org/wiki/Power_set">power set</a> of the set <script type="math/tex">\{1, \ldots, n\}</script>.</p>

<hr />

<p><strong>Solution</strong>: We are required to construct a set containing all subsets of <script type="math/tex">\{1, \ldots, n\}</script>. This can easily be computed recursively; <script type="math/tex"> \mathcal P \left({n}\right)</script> equals the concatanation of <script type="math/tex"> \mathcal P \left({n-1}\right)</script> with 
the set of sets resulted by appending $n$ to every set in <script type="math/tex"> \mathcal P \left({n-1}\right)</script>. The termination is <script type="math/tex">\mathcal P \left({0}\right)</script>, which is simply the empty set.</p>

<p>The following is a Scala implementation:</p>

<p><code>Scala
    def powerSet(n: Int): List[Set[Int]] = if (n == 0) List(Set[Int]()) else {
      val rec = powerSet(n - 1)
      rec ::: rec.map(s =&gt; s + n)
    }
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Plus Minus Array]]></title>
    <link href="http://yoursite.com/blog/2014/12/01/plus-minus-array/"/>
    <updated>2014-12-01T23:17:39+02:00</updated>
    <id>http://yoursite.com/blog/2014/12/01/plus-minus-array</id>
    <content type="html"><![CDATA[<p><strong>Question</strong>: We are givan an array <script type="math/tex">A</script> (with size <script type="math/tex">n</script>) where every cell holds either ‘+’ or ‘-‘.
We’re told that <script type="math/tex">A[0]</script> = ‘+’ and that <script type="math/tex">A[n-1]</script> = ‘-‘. Describe an algorithm to find index <script type="math/tex">j</script> such that <script type="math/tex">A[j]</script> = ‘+’
and <script type="math/tex">A[j+1]</script> = ‘-‘.</p>

<p><strong>Example</strong>: </p>

<table>
  <tbody>
    <tr>
      <td>A</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
      <td>-</td>
      <td>+</td>
      <td>-</td>
    </tr>
    <tr>
      <td>id</td>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
      <td>8</td>
      <td>9</td>
    </tr>
  </tbody>
</table>

<p>Correct answers in this example are <script type="math/tex">j=1</script>, <script type="math/tex">j=5</script>, <script type="math/tex">j=8</script> (each one is acceptable, no need to return them all).</p>

<hr />

<p><strong>Solution</strong>: We can use logic similar to binary search to solve this in <script type="math/tex">O(\log{} n)</script> time complexity. We’ll use two 
variables, <script type="math/tex">l</script> and <script type="math/tex">h</script>, and maintain the following invariant: <script type="math/tex">A[l]</script> = ‘+’ and <script type="math/tex">A[r]</script> = ‘-‘. In each step
we’ll check if <script type="math/tex">r=l+1</script>. If so, we’re done. else, we find the center point <script type="math/tex">c=\frac{l+r}{2}</script>. If <script type="math/tex">A[c</script>] = ‘+’ we’ll
update <script type="math/tex">l=c</script>, else <script type="math/tex">r=c</script>. Since in each step the distance between <script type="math/tex">l</script> and <script type="math/tex">r</script> diminishes, we know the process
will eventually terminate.</p>

<p>&#8220;` Scala
    class PlusMinusArray {
    def search(array: Array[Char]): Int = {
      def searchInner(l: Int, h: Int): Int = {
        if (h == l + 1) l else {
          val mid: Int = l + (h - l) / 2
          array(mid) match {
            case ‘+’ =&gt; searchInner(mid, h) 
            case ‘-‘ =&gt; searchInner(l, mid)
            case _   =&gt; throw new IllegalArgumentException(“invalid character “ + array(mid)) 
          }
        }
      }</p>

<pre><code>  searchInner(0, array.size - 1)
}
} ``` Have any questions / remarks? leave them at the commonts below!
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Square Root]]></title>
    <link href="http://yoursite.com/blog/2014/11/29/square-root/"/>
    <updated>2014-11-29T18:20:21+02:00</updated>
    <id>http://yoursite.com/blog/2014/11/29/square-root</id>
    <content type="html"><![CDATA[<p><strong>Question</strong>: Givan two real numbers <script type="math/tex">x</script> and <script type="math/tex">\epsilon</script>, find the square root of <script type="math/tex">x</script> within error margin of <script type="math/tex">\epsilon</script> (that is, find <script type="math/tex">y</script> such that <script type="math/tex">% &lt;![CDATA[
 \lvert \sqrt{x} - y \rvert < \epsilon %]]&gt;</script>). Obviously, you’re not allowed to use the startand <code>sqrt</code> function. </p>

<hr />

<p><strong>Solution</strong>: The general idea is to guess a solution <script type="math/tex">y</script> and then iteratively improve it. If <script type="math/tex">y^2 > x</script>, we should aim lower, so in the next step we’ll try <script type="math/tex">y - stepSize</script>. 
else, we should aim higher, so we’ll try <script type="math/tex">y + stepSize</script>. In each step we’ll halve the <script type="math/tex">stepSize</script>.</p>

<p>The following is a Scala implementation:</p>

<p>&#8220;` Scala
    class Sqrt {
      def sqrt(x : Double, err: Double): Double = sqrtHelper(x, err, 0.5 * x, 0.25 * x)</p>

<pre><code>  def sqrtHelper(x: Double, allowedError: Double, curr: Double, stepSize: Double): Double = {
    val err = x - (curr * curr)
    if (Math.abs(err) &lt;= allowedError)
      curr
    else
      sqrtHelper(x, allowedError, if (err &gt; 0) curr + stepSize else curr - stepSize, 0.5 * stepSize)
  }
} ```
</code></pre>

<p>Have any questions / remarks? leave them at the commonts below!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Keypad]]></title>
    <link href="http://yoursite.com/blog/2014/11/28/keypad/"/>
    <updated>2014-11-28T12:43:56+02:00</updated>
    <id>http://yoursite.com/blog/2014/11/28/keypad</id>
    <content type="html"><![CDATA[<p><strong>Question</strong>: Given the English alphabet, ‘a’ through ‘z’ (lowercase), and an imaginary onscreen keyboard with the letters laid out in 6 rows and 5 columns:</p>

<pre><code>a b c d e
f g h i j
k l m n o
p q r s t
u v w x y
z
</code></pre>

<p>write a function that given a word will produce the sequence of key presses required to type out the word on the onscreen keyboard. The function should return the sequence string (up - ‘u’, down - ‘d’, left - ‘l’, right - ‘r’ and enter - ‘!’).</p>

<hr />

<p><strong>Solution</strong>: We build the solution in steps. We start with movements between two characters. To do it, we can find the x/y coordinates of both characters
and then recursively diminish the x and y differences. To adapt the solution for full word we should split the word to a list of character pairs (for example, convert “hello” to [(‘h’, ‘e’), (‘e’, ‘l’), (‘l’, ‘l’), (‘l’, ‘o’)]). 
Two more required changes are to prepend ‘a’ to the word (to start movemonts from the top left corner of the keypad) and insert ‘!’ whenever we reached a character of the word.</p>

<p>The following is a Scala solution:</p>

<p>&#8220;` Scala
    class Keypad {</p>

<pre><code>  val rowLength = 5

  def movements(from: (Int, Int), to: (Int, Int)): List[String] = if (from == to) Nil else {
    val xDiff = to._1 - from._1
    val yDiff = to._2 - from._2
    if (xDiff &lt; 0) 
      "l" :: movements(left(from), to)
    else if (yDiff &gt; 0)
      "d" :: movements(down(from), to)
    else if (yDiff &lt; 0)
      "u" :: movements(up(from), to)
    else 
      "r" :: movements(right(from), to)
  }

  def movements(from: Char, to: Char): List[String] = movements(coords(from), coords(to))

  def movements(pairs: List[(Char, Char)]): List[String] = if (pairs.isEmpty) Nil else 
    movements(pairs.head._1, pairs.head._2) ::: List("!") ::: movements(pairs.tail)

  def movements(word: String): List[String] = { 
    val chars = 'a' :: word.toList
    val pairs = chars zip chars.tail
    movements(pairs)
  }

  def coords(c: Char): (Int, Int) = {
    val i = c - 'a'
    (i % rowLength, i / rowLength)
  }
  
  def down(p: (Int, Int)): (Int, Int) = (p._1, p._2 + 1)
  def up(p: (Int, Int)): (Int, Int) = (p._1, p._2 - 1)
  def right(p: (Int, Int)): (Int, Int) = (p._1 + 1, p._2)
  def left(p: (Int, Int)): (Int, Int) = (p._1 - 1, p._2)
} ```
</code></pre>

<p>Have any questions / remarks? leave them at the commonts below!</p>
]]></content>
  </entry>
  
</feed>
