<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | Interview Bits]]></title>
  <link href="http://interviewbits.herokuapp.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://interviewbits.herokuapp.com/"/>
  <updated>2014-12-20T10:27:34+02:00</updated>
  <id>http://interviewbits.herokuapp.com/</id>
  <author>
    <name><![CDATA[Asaf David]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rectangles Store]]></title>
    <link href="http://interviewbits.herokuapp.com/blog/2014/12/18/rectangles-store/"/>
    <updated>2014-12-18T14:57:53+02:00</updated>
    <id>http://interviewbits.herokuapp.com/blog/2014/12/18/rectangles-store</id>
    <content type="html"><![CDATA[<p><strong>Question</strong>: Your task is to implement a class that stores rectangles. A rectangle is defined by the following interface:</p>

<p><code>Java
    public interface Rectangle {
        int getLeft();
        int getTop();
        int getRight();
        int getBottom();
    }
</code></p>

<p>You should implement the following interface:</p>

<p><code>Java
    public interface RectanglesStore {
        void initialize(Rectangle bounds, Collection&lt;Rectangle&gt; rectangles);
        Rectangle findRectangleAt(int x, int y);
    }
</code></p>

<p>The arguments to the <code>initialize</code> method are a rectangle that represents the bounds (e.g. the area in which other rectangles can appear), and a collection of rectangles.
You are required to store these rectangles in an efficient manner (in terms of memory consumption), and to later return the topmost rectangle per specified <script type="math/tex">x</script>, <script type="math/tex">y</script> location (or null in case no rectangle exists in the specified location) in the most time efficient way.</p>

<p>Note: The solution should support a large number of rectangles, and an extremely large bounding rectangle, so the following solutions are invalid:</p>

<ul>
  <li>a simple collection of rectangles (isn’t efficient enough performance-wise)</li>
  <li>a map of each point to its corresponding rectangle (isn’t efficient enough memory-wise)</li>
</ul>

<p><strong>Solution</strong>:</p>

<p>In addition to the rectangles themselves, our solution will maintain the following 4 sorted sets: </p>

<ul>
  <li><code>lefts</code> - holds the <em>left</em> values of all rectangles, each with a link to the corresponding rectangle</li>
  <li><code>rights</code> - same as above, but <em>right</em> values</li>
  <li><code>tops</code> - same as above, but <em>top</em> values</li>
  <li><code>bottoms</code> - same as above, but <em>bottom</em> values</li>
</ul>

<p>The following is a Java solution:</p>

<p>&#8220;` Java
    public class RectangleStoreImpl implements RectanglesStore {</p>

<pre><code>    private Rectangle bounds;
    private List&lt;Rectangle&gt; rectangles;
    private int numRectangles;
    private TreeSet&lt;Pair&lt;Integer, Integer&gt;&gt; lefts, rights, tops, bottoms;

    private class PairComparator implements Comparator&lt;Pair&lt;Integer, Integer&gt;&gt; {
        @Override
        public int compare(Pair&lt;Integer, Integer&gt; p1, Pair&lt;Integer, Integer&gt; p2) {
            return Integer.compare(p1.getFirst(), p2.getFirst());
        }
    }

    @Override
    public void initialize(Rectangle bounds, Collection&lt;Rectangle&gt; rectangles) {
        this.bounds = bounds;
        this.rectangles = new ArrayList&lt;&gt;(rectangles);

        final PairComparator comp = new PairComparator();
        lefts   = new TreeSet&lt;&gt;(comp);
        tops    = new TreeSet&lt;&gt;(comp);
        rights  = new TreeSet&lt;&gt;(comp);
        bottoms = new TreeSet&lt;&gt;(comp);

        int numRectangles = 0;

        for (Rectangle r : rectangles) {
            if (r.getLeft()   &lt; bounds.getLeft()  ||
                r.getTop()    &lt; bounds.getTop()   ||
                r.getRight()  &gt; bounds.getRight() ||
                r.getBottom() &gt; bounds.getBottom())
                throw new IllegalArgumentException("rectangle" + r + "is out of bounds");

            lefts.add(  new Pair&lt;Integer, Integer&gt;(r.getLeft(),   numRectangles));
            tops.add(   new Pair&lt;Integer, Integer&gt;(r.getTop(),    numRectangles));
            rights.add( new Pair&lt;Integer, Integer&gt;(r.getRight(),  numRectangles));
            bottoms.add(new Pair&lt;Integer, Integer&gt;(r.getBottom(), numRectangles));
            numRectangles++;
        }    
    }

    @Override
    public Rectangle findRectangleAt(int x, int y) {
        if (x &lt; bounds.getLeft() || x &gt; bounds.getRight() ||
            y &lt; bounds.getTop()  || y &gt; bounds.getBottom()) {
            throw new IllegalArgumentException("requested point is outside of bounding box");
        }
        final Pair&lt;Integer, Integer&gt; px0 = new Pair&lt;Integer, Integer&gt;(x, 0),
                                     py0 = new Pair&lt;Integer, Integer&gt;(y, 0);

        final List&lt;Integer&gt;   rLefts = new ArrayList&lt;&gt;(),
                               rTops = new ArrayList&lt;&gt;(),
                             rRights = new ArrayList&lt;&gt;(),
                            rBottoms = new ArrayList&lt;&gt;();

        for (Pair&lt;Integer, Integer&gt; p :   lefts.headSet(px0, true)) {  rLefts.add(p.getRight());}
        for (Pair&lt;Integer, Integer&gt; p :    tops.headSet(py0, true)) {   rTops.add(p.getRight());}
        for (Pair&lt;Integer, Integer&gt; p :  rights.tailSet(px0, true)) { rRights.add(p.getRight());}
        for (Pair&lt;Integer, Integer&gt; p : bottoms.tailSet(py0, true)) {rBottoms.add(p.getRight());}

        // since rTops is ordered from top down, the first rectangle found is the topmost

        for (Integer numRect : rTops) {
            if (rBottoms.contains(numRect) &amp;&amp;
                rLefts.contains(numRect) &amp;&amp;
                rRights.contains(numRect)) {
                return rectangles.get(numRect);
            }
        }

        return null;  // no rectangle was found
    }

} ```
</code></pre>

]]></content>
  </entry>
  
</feed>
