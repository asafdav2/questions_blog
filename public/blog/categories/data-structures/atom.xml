<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Data Structures | Interview Bits]]></title>
  <link href="http://interviewbits.herokuapp.com/blog/categories/data-structures/atom.xml" rel="self"/>
  <link href="http://interviewbits.herokuapp.com/"/>
  <updated>2015-01-11T07:43:28+02:00</updated>
  <id>http://interviewbits.herokuapp.com/</id>
  <author>
    <name><![CDATA[Asaf David]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rectangles Store]]></title>
    <link href="http://interviewbits.herokuapp.com/blog/2014/12/18/rectangles-store/"/>
    <updated>2014-12-18T14:57:53+02:00</updated>
    <id>http://interviewbits.herokuapp.com/blog/2014/12/18/rectangles-store</id>
    <content type="html"><![CDATA[<p><strong>Question</strong>: Your task is to implement a class that stores rectangles. A rectangle is defined by the following interface:</p>

<p><code>Java
    public interface Rectangle {
        int getLeft();
        int getTop();
        int getRight();
        int getBottom();
    }
</code></p>

<p>You should implement the following interface:</p>

<p><code>Java
    public interface RectanglesStore {
        void initialize(Rectangle bounds, Collection&lt;Rectangle&gt; rectangles);
        Rectangle findRectangleAt(int x, int y);
    }
</code></p>

<p>The arguments to the <code>initialize</code> method are a rectangle that represents the bounds (e.g. the area in which other rectangles can appear), and a collection of rectangles.
You are required to store these rectangles in an efficient manner (in terms of memory consumption), and to later return the topmost rectangle per specified <script type="math/tex">x</script>, <script type="math/tex">y</script> location (or null in case no rectangle exists in the specified location) in the most time efficient way.</p>

<p>Note: The solution should support a large number of rectangles, and an extremely large bounding rectangle, so the following solutions are invalid:</p>

<ul>
  <li>a simple collection of rectangles (isn’t efficient enough performance-wise)</li>
  <li>a map of each point to its corresponding rectangle (isn’t efficient enough memory-wise)
<!--more--></li>
</ul>

<hr />

<p><strong>Solution</strong>:</p>

<p>In addition to the rectangles themselves, our solution will maintain 4 sorted sets: </p>

<ul>
  <li><code>lefts</code> - holds the <em>left</em> values of all rectangles</li>
  <li><code>rights</code> - holds the <em>right</em> values of all rectangles </li>
  <li><code>tops</code> - holds the <em>top</em> values of all rectangles  </li>
  <li><code>bottoms</code> - holds the <em>bottom</em> values of all rectangles</li>
</ul>

<p>Each entry in the preceeding sets will also hold the id of the corresponding rectangle.</p>

<p>Now, given <script type="math/tex">x,y</script> coordinates as input to <code>findRectangleAt</code>, we can filter all relevant rectangles:</p>

<ul>
  <li><code>rLefts</code> - list of rectangle id for all <code>left</code> entries having value <em>lower</em> than <script type="math/tex">x</script>.</li>
  <li><code>rRights</code> - list of rectangle id for all <code>right</code> entries having value <em>greater</em> than <script type="math/tex">x</script>.</li>
  <li><code>rTops</code> - list of rectangle id for all <code>tops</code> entries having value <em>lower</em> than <script type="math/tex">y</script>.</li>
  <li><code>rBottoms</code> - list of rectangle id for all <code>bottoms</code> entries having value <em>greater</em> than <script type="math/tex">y</script>.</li>
</ul>

<p>The point <script type="math/tex">(x,y)</script> is contained in every rectangle whose id appears in the 4 afromentioned lists.
Since we want to return the topmost such rectangle, and since the ids in <code>rTops</code> are sorted according to an ascending <script type="math/tex">y</script> value,
we can simply look for the first id in <code>rTops</code> that alse appear in <code>rLefts</code>, <code>rRights</code> and <code>rBottoms</code> and return it.</p>

<p>The following is a Java solution:</p>

<p>&#8220;` Java
    public class RectangleStoreImpl implements RectanglesStore {</p>

<pre><code>    private Rectangle bounds;
    private List&lt;Rectangle&gt; rectangles;
    private int numRectangles;
    private TreeSet&lt;Pair&lt;Integer, Integer&gt;&gt; lefts, rights, tops, bottoms;

    private class PairComparator implements Comparator&lt;Pair&lt;Integer, Integer&gt;&gt; {
        @Override
        public int compare(Pair&lt;Integer, Integer&gt; p1, Pair&lt;Integer, Integer&gt; p2) {
            return Integer.compare(p1.getFirst(), p2.getFirst());
        }
    }

    @Override
    public void initialize(Rectangle bounds, Collection&lt;Rectangle&gt; rectangles) {
        this.bounds = bounds;
        this.rectangles = new ArrayList&lt;&gt;(rectangles);

        final PairComparator comp = new PairComparator();
        lefts   = new TreeSet&lt;&gt;(comp);
        tops    = new TreeSet&lt;&gt;(comp);
        rights  = new TreeSet&lt;&gt;(comp);
        bottoms = new TreeSet&lt;&gt;(comp);

        int numRectangles = 0;

        for (Rectangle r : rectangles) {
            if (r.getLeft()   &lt; bounds.getLeft()  ||
                r.getTop()    &lt; bounds.getTop()   ||
                r.getRight()  &gt; bounds.getRight() ||
                r.getBottom() &gt; bounds.getBottom())
                throw new IllegalArgumentException("rectangle" + r + "is out of bounds");

            lefts.add(  new Pair&lt;Integer, Integer&gt;(r.getLeft(),   numRectangles));
            tops.add(   new Pair&lt;Integer, Integer&gt;(r.getTop(),    numRectangles));
            rights.add( new Pair&lt;Integer, Integer&gt;(r.getRight(),  numRectangles));
            bottoms.add(new Pair&lt;Integer, Integer&gt;(r.getBottom(), numRectangles));
            numRectangles++;
        }    
    }

    @Override
    public Rectangle findRectangleAt(int x, int y) {
        if (x &lt; bounds.getLeft() || x &gt; bounds.getRight() ||
            y &lt; bounds.getTop()  || y &gt; bounds.getBottom()) {
            throw new IllegalArgumentException("requested point is outside of bounding box");
        }
        final Pair&lt;Integer, Integer&gt; px0 = new Pair&lt;Integer, Integer&gt;(x, 0),
                                     py0 = new Pair&lt;Integer, Integer&gt;(y, 0);

        final List&lt;Integer&gt;   rLefts = new ArrayList&lt;&gt;(),
                               rTops = new ArrayList&lt;&gt;(),
                             rRights = new ArrayList&lt;&gt;(),
                            rBottoms = new ArrayList&lt;&gt;();

        for (Pair&lt;Integer, Integer&gt; p :   lefts.headSet(px0, true)) {  rLefts.add(p.getRight());}
        for (Pair&lt;Integer, Integer&gt; p :    tops.headSet(py0, true)) {   rTops.add(p.getRight());}
        for (Pair&lt;Integer, Integer&gt; p :  rights.tailSet(px0, true)) { rRights.add(p.getRight());}
        for (Pair&lt;Integer, Integer&gt; p : bottoms.tailSet(py0, true)) {rBottoms.add(p.getRight());}

        // since rTops is ordered from top down, the first rectangle found is the topmost

        for (Integer numRect : rTops) {
            if (rBottoms.contains(numRect) &amp;&amp;
                rLefts.contains(numRect) &amp;&amp;
                rRights.contains(numRect)) {
                return rectangles.get(numRect);
            }
        }

        return null;  // no rectangle was found
    }

} ```
</code></pre>

<p>Have any questions / remarks? leave them at the commonts below!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Insert, Remove, Contains and Random in O(1)]]></title>
    <link href="http://interviewbits.herokuapp.com/blog/2014/11/29/insert/"/>
    <updated>2014-11-29T22:59:13+02:00</updated>
    <id>http://interviewbits.herokuapp.com/blog/2014/11/29/insert</id>
    <content type="html"><![CDATA[<p><strong>Question</strong>: Design and implement a data structure that offers the operations Insert, Delete, Contains and RandomItem, all in <script type="math/tex">O(1)</script> (amortized) time complexity.
<!--more--></p>

<hr />

<p><strong>Solution</strong>: Our data structure will be made of two data structures: an array <script type="math/tex">A</script> to holds the items, and a hashtable <script type="math/tex">H</script> that map each item to its position in the array.
For example, after inserting items ‘b’, ‘a’, ‘z’, the data structures content will be as follows:</p>

<pre><code>A = ['b', 'a', 'z']
B = {'a' : 1, 'b' : 0, 'z' : 2}
</code></pre>

<ul>
  <li>insert(v): append <script type="math/tex">v</script> to <script type="math/tex">A</script> (let <script type="math/tex">i</script> be it’s index). Set <script type="math/tex">H[v] = i</script>.</li>
  <li>remove(v): let <script type="math/tex">m</script> be the last index in <script type="math/tex">A</script> and let <script type="math/tex">d=A[m]</script>. let <script type="math/tex">i= H[v]</script> (that is, the index in <script type="math/tex">A</script> of the value to be removed). Set <script type="math/tex">A[i]=d</script>, <script type="math/tex">H[d]=i</script>, decrease the size of the array by one and remove <script type="math/tex">H[v]</script>.</li>
  <li>contains(v): return <script type="math/tex">H.contains(value)</script></li>
  <li>getRandomElement(): let <script type="math/tex">r</script>=random(current size of A). return <script type="math/tex">A[r]</script>.</li>
</ul>

]]></content>
  </entry>
  
</feed>
